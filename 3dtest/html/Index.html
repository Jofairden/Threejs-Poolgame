<!DOCTYPE html>
<html>
<head>
    <meta charset=utf-8>
    <title>My first three.js app</title>
    <style>
        body { margin: 0; }
        canvas { width: 100%; height: 100% }
    </style>
</head>
<body>
<script src="js/three.js"></script>
<script src="js/three.min.js"></script>
<script src="js/OrbitControls.js"></script>
<script src="js/three.module.js"></script>
<script src="js/stats.min.js"></script>

<div id="container">
<script>
    var container;
    var camera, controls, scene, renderer, colGroup, raycaster, speed, clock, stats;

    // debugging stats
    stats = new Stats();
    stats.showPanel(0); // 0: fps, 1: ms, 2: mb, 3+: custom

    // append debugging stats to body
    document.body.appendChild(stats.dom);

    // camera

    camera = new THREE.PerspectiveCamera( 60, window.innerWidth / window.innerHeight, 1, 1000 );
    camera.position.z = 500;

    // controls

    controls = new THREE.OrbitControls( camera );
    controls.maxPolarAngle = Math.PI / 2 - 0.30;
    controls.maxDistance = 50;
    controls.minDistance = 10;

    // scene/groups

    scene = new THREE.Scene();
    colGroup = new THREE.Group();

    // raycaster

    raycaster = new THREE.Raycaster();

    // skybox

    var skyCube = new THREE.CubeGeometry( 1000, 1000, 1000 );

    var cubeMaterials =
            [
                new THREE.MeshBasicMaterial( { map: new THREE.TextureLoader().load( "img/skybox/posx.jpg" ), side: THREE.DoubleSide }),
                new THREE.MeshBasicMaterial( { map: new THREE.TextureLoader().load( "img/skybox/negx.jpg" ), side: THREE.DoubleSide }),
                new THREE.MeshBasicMaterial( { map: new THREE.TextureLoader().load( "img/skybox/posy.jpg" ), side: THREE.DoubleSide }),
                new THREE.MeshBasicMaterial( { map: new THREE.TextureLoader().load( "img/skybox/negy.jpg" ), side: THREE.DoubleSide }),
                new THREE.MeshBasicMaterial( { map: new THREE.TextureLoader().load( "img/skybox/posz.jpg" ), side: THREE.DoubleSide }),
                new THREE.MeshBasicMaterial( { map: new THREE.TextureLoader().load( "img/skybox/negz.jpg" ), side: THREE.DoubleSide })
            ];

    var cubeMaterial = new THREE.MeshFaceMaterial( cubeMaterials );

    var cube = new THREE.Mesh(skyCube, cubeMaterial);
    scene.add( cube );

    var randomLight = new THREE.AmbientLight( 0xFFFFFF, 0.3 );
    scene.add( randomLight );


    // textures

    var textureLoader = new THREE.TextureLoader();
    var clothTexture = new textureLoader.load("img/cloth.jpg");
    var woodTexture = new textureLoader.load("img/wood.jpg");
    var floorTexture = new textureLoader.load("img/floor.jpg");

    clothTexture.wrapS = THREE.RepeatWrapping;
    clothTexture.wrapT = THREE.RepeatWrapping;
    clothTexture.repeat.set(2,2);

    woodTexture.wrapS = THREE.RepeatWrapping;
    woodTexture.wrapT = THREE.RepeatWrapping;
    woodTexture.repeat.set(1,1);

    floorTexture.wrapS = THREE.RepeatWrapping;
    floorTexture.wrapT = THREE.RepeatWrapping;
    floorTexture.repeat.set(4,4);

    // movement

    var cubeDirection = new THREE.Vector3();
    cubeDirection.x = -1;
    cubeDirection.normalize();

    speed = new THREE.Vector3();

    clock = new THREE.Clock();

    var rotationPerFrame = 0.010;
    var rotationVector = new THREE.Vector3(rotationPerFrame,rotationPerFrame,rotationPerFrame);

    // shapes

    colCube = new THREE.Mesh(
            new THREE.BoxGeometry(0.5,0.5,0.5),
            new THREE.MeshPhongMaterial( { color:0xf0f0f0 } )
    );

    tableMesh = new THREE.Mesh(
            new THREE.BoxGeometry( 27.2, 0.7, 14.4, 1, 0 ),
            new THREE.MeshPhongMaterial( {shading: THREE.FlatShading, map:clothTexture } )
    );

    tableWall1 = new THREE.Mesh(
            new THREE.BoxGeometry( 28.2, 1.2, 0.5, 1, 0),
            new THREE.MeshPhongMaterial( {shading: THREE.FlatShading, map:woodTexture } )
    );

    tableWall2 = new THREE.Mesh(
            new THREE.BoxGeometry( 28.2, 1.2, 0.5, 1, 0),
            new THREE.MeshPhongMaterial( {shading: THREE.FlatShading, map:woodTexture } )
    );

    tableWall3 = new THREE.Mesh(
            new THREE.BoxGeometry( 0.5, 1.2, 14.4, 1, 0),
            new THREE.MeshPhongMaterial( {shading: THREE.FlatShading, map:woodTexture } )
    );

    tableWall4 = new THREE.Mesh(
            new THREE.BoxGeometry( 0.5, 1.2, 14.4, 1, 0),
            new THREE.MeshPhongMaterial( {shading: THREE.FlatShading, map:woodTexture } )
    );

    tableWall1.position.y = 0.25;
    tableWall1.position.z = 7.45;

    tableWall2.position.y = 0.25;
    tableWall2.position.z = -7.45;

    tableWall3.position.x = 13.85;
    tableWall3.position.y = 0.25;

    tableWall4.position.x = -13.85;
    tableWall4.position.y = 0.25;

    tableMesh.position.y = 0;

    colCube.position.y = 0.50;

    colGroup.add (tableMesh, tableWall1, tableWall2, tableWall3, tableWall4);

    scene.add(colCube, colGroup );

    // lights

    var ambientLight = new THREE.AmbientLight(0x444444);
    scene.add(ambientLight);
    var directionalLight = new THREE.DirectionalLight(0xcccccc, 1);
    scene.add(directionalLight);

    // renderer

    renderer = new THREE.WebGLRenderer({
        alpha: true,     // Transparent background
        antialias: true // Smooth edges
    });
    renderer.setSize( window.innerWidth, window.innerHeight );

    container = document.getElementById( 'container' );
    container.appendChild( renderer.domElement );

    window.addEventListener( 'resize', onWindowResize, false );

    render();

    function onWindowResize() {

        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();

        renderer.setSize( window.innerWidth, window.innerHeight );

        render();

    }
    function render() {
        requestAnimationFrame(render);

        renderer.render( scene, camera );

        colCube.rotation.setFromVector3(colCube.rotation.toVector3().add(rotationVector));

        colCube.position.add(speed.copy(cubeDirection).multiplyScalar(clock.getDelta()*20));

        raycaster.set(colCube.position, cubeDirection);

        var intersections = raycaster.intersectObjects(colGroup.children);

        if(intersections.length > 0) {
            var intersection = intersections[0];

            if(intersection.distance < 0.5) {
                cubeDirection.reflect(intersection.face.normal);
            }
        }

        stats.update();
    }

</script>
</div>
</body>
</html>